// Code generated by go-swagger; DO NOT EDIT.

package admin

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new admin API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new admin API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new admin API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for admin API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationxWwwFormUrlencoded sets the Content-Type header to "application/x-www-form-urlencoded".
func WithContentTypeApplicationxWwwFormUrlencoded(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/x-www-form-urlencoded"}
}

// WithContentTypeApplicationXML sets the Content-Type header to "application/xml".
func WithContentTypeApplicationXML(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/xml"}
}

// WithContentTypeMultipartFormData sets the Content-Type header to "multipart/form-data".
func WithContentTypeMultipartFormData(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"multipart/form-data"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AdminAccountAction(params *AdminAccountActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountActionOK, error)

	AdminAccountApprove(params *AdminAccountApproveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountApproveOK, error)

	AdminAccountGet(params *AdminAccountGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountGetOK, error)

	AdminAccountReject(params *AdminAccountRejectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountRejectOK, error)

	AdminAccountsGetV1(params *AdminAccountsGetV1Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountsGetV1OK, error)

	AdminAccountsGetV2(params *AdminAccountsGetV2Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountsGetV2OK, error)

	AdminReportGet(params *AdminReportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportGetOK, error)

	AdminReportResolve(params *AdminReportResolveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportResolveOK, error)

	AdminReports(params *AdminReportsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportsOK, error)

	AdminRuleGet(params *AdminRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminRuleGetOK, error)

	AdminsRuleGet(params *AdminsRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminsRuleGetOK, error)

	DomainAllowCreate(params *DomainAllowCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowCreateOK, error)

	DomainAllowDelete(params *DomainAllowDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowDeleteOK, error)

	DomainAllowGet(params *DomainAllowGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowGetOK, error)

	DomainAllowsGet(params *DomainAllowsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowsGetOK, error)

	DomainBlockCreate(params *DomainBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockCreateOK, error)

	DomainBlockDelete(params *DomainBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockDeleteOK, error)

	DomainBlockGet(params *DomainBlockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockGetOK, error)

	DomainBlocksGet(params *DomainBlocksGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlocksGetOK, error)

	DomainKeysExpire(params *DomainKeysExpireParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainKeysExpireAccepted, error)

	DomainPermissionDraftAccept(params *DomainPermissionDraftAcceptParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftAcceptOK, error)

	DomainPermissionDraftCreate(params *DomainPermissionDraftCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftCreateOK, error)

	DomainPermissionDraftGet(params *DomainPermissionDraftGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftGetOK, error)

	DomainPermissionDraftRemove(params *DomainPermissionDraftRemoveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftRemoveOK, error)

	DomainPermissionDraftsGet(params *DomainPermissionDraftsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftsGetOK, error)

	DomainPermissionExcludeCreate(params *DomainPermissionExcludeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeCreateOK, error)

	DomainPermissionExcludeDelete(params *DomainPermissionExcludeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeDeleteOK, error)

	DomainPermissionExcludeGet(params *DomainPermissionExcludeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeGetOK, error)

	DomainPermissionExcludesGet(params *DomainPermissionExcludesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludesGetOK, error)

	DomainPermissionSubscriptionCreate(params *DomainPermissionSubscriptionCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionCreateOK, error)

	DomainPermissionSubscriptionGet(params *DomainPermissionSubscriptionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionGetOK, error)

	DomainPermissionSubscriptionRemove(params *DomainPermissionSubscriptionRemoveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionRemoveOK, error)

	DomainPermissionSubscriptionTest(params *DomainPermissionSubscriptionTestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionTestOK, error)

	DomainPermissionSubscriptionUpdate(params *DomainPermissionSubscriptionUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionUpdateOK, error)

	DomainPermissionSubscriptionsGet(params *DomainPermissionSubscriptionsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionsGetOK, error)

	DomainPermissionSubscriptionsPreviewGet(params *DomainPermissionSubscriptionsPreviewGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionsPreviewGetOK, error)

	EmojiCategoriesGet(params *EmojiCategoriesGetParams, opts ...ClientOption) (*EmojiCategoriesGetOK, error)

	EmojiCreate(params *EmojiCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiCreateOK, error)

	EmojiDelete(params *EmojiDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiDeleteOK, error)

	EmojiGet(params *EmojiGetParams, opts ...ClientOption) (*EmojiGetOK, error)

	EmojiUpdate(params *EmojiUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiUpdateOK, error)

	EmojisGet(params *EmojisGetParams, opts ...ClientOption) (*EmojisGetOK, error)

	HeaderFilterAllowCreate(params *HeaderFilterAllowCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowCreateOK, error)

	HeaderFilterAllowDelete(params *HeaderFilterAllowDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowDeleteAccepted, error)

	HeaderFilterAllowGet(params *HeaderFilterAllowGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowGetOK, error)

	HeaderFilterAllowsGet(params *HeaderFilterAllowsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowsGetOK, error)

	HeaderFilterBlockCreate(params *HeaderFilterBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockCreateOK, error)

	HeaderFilterBlockDelete(params *HeaderFilterBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockDeleteAccepted, error)

	HeaderFilterBlockGet(params *HeaderFilterBlockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockGetOK, error)

	HeaderFilterBlocksGet(params *HeaderFilterBlocksGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlocksGetOK, error)

	MediaCleanup(params *MediaCleanupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MediaCleanupOK, error)

	MediaRefetch(params *MediaRefetchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MediaRefetchAccepted, error)

	RuleCreate(params *RuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleCreateOK, error)

	RuleDelete(params *RuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleDeleteOK, error)

	RuleUpdate(params *RuleUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleUpdateOK, error)

	TestEmailSend(params *TestEmailSendParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestEmailSendAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AdminAccountAction performs an admin action on an account
*/
func (a *Client) AdminAccountAction(params *AdminAccountActionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountActionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountActionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountAction",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/accounts/{id}/action",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountActionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountActionOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountAction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminAccountApprove approves pending account
*/
func (a *Client) AdminAccountApprove(params *AdminAccountApproveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountApproveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountApproveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountApprove",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/accounts/{id}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountApproveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountApproveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountApprove: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminAccountGet views one account
*/
func (a *Client) AdminAccountGet(params *AdminAccountGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/accounts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminAccountReject rejects pending account
*/
func (a *Client) AdminAccountReject(params *AdminAccountRejectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountRejectOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountRejectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountReject",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/accounts/{id}/reject",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountRejectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountRejectOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountReject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	AdminAccountsGetV1 views page through known accounts according to given filters

	Returned accounts will be ordered alphabetically (a-z) by domain + username.

The next and previous queries can be parsed from the returned Link header.
Example:

```
<https://example.org/api/v1/admin/accounts?limit=80&max_id=example.org%2F%40someone>; rel="next", <https://example.org/api/v1/admin/accounts?limit=80&min_id=example.org%2F%40someone_else>; rel="prev"
````
*/
func (a *Client) AdminAccountsGetV1(params *AdminAccountsGetV1Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountsGetV1OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountsGetV1Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountsGetV1",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/accounts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountsGetV1Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountsGetV1OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountsGetV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	AdminAccountsGetV2 views page through known accounts according to given filters

	Returned accounts will be ordered alphabetically (a-z) by domain + username.

The next and previous queries can be parsed from the returned Link header.
Example:

```
<https://example.org/api/v2/admin/accounts?limit=80&max_id=example.org%2F%40someone>; rel="next", <https://example.org/api/v2/admin/accounts?limit=80&min_id=example.org%2F%40someone_else>; rel="prev"
````
*/
func (a *Client) AdminAccountsGetV2(params *AdminAccountsGetV2Params, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminAccountsGetV2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminAccountsGetV2Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminAccountsGetV2",
		Method:             "GET",
		PathPattern:        "/api/v2/admin/accounts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminAccountsGetV2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminAccountsGetV2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminAccountsGetV2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminReportGet views user moderation report with the given id
*/
func (a *Client) AdminReportGet(params *AdminReportGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminReportGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminReportGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/reports/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminReportGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminReportGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminReportGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminReportResolve marks a report as resolved
*/
func (a *Client) AdminReportResolve(params *AdminReportResolveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportResolveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminReportResolveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminReportResolve",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/reports/{id}/resolve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminReportResolveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminReportResolveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminReportResolve: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	AdminReports views user moderation reports

	The reports will be returned in descending chronological order (newest first), with sequential IDs (bigger = newer).

The next and previous queries can be parsed from the returned Link header.

Example:

```
<https://example.org/api/v1/admin/reports?limit=20&max_id=01FC0SKA48HNSVR6YKZCQGS2V8>; rel="next", <https://example.org/api/v1/admin/reports?limit=20&min_id=01FC0SKW5JK2Q4EVAV2B462YY0>; rel="prev"
````
*/
func (a *Client) AdminReports(params *AdminReportsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminReportsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminReportsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminReports",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/reports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminReportsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminReportsOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminReports: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminRuleGet views instance rule with the given id
*/
func (a *Client) AdminRuleGet(params *AdminRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminRuleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminRuleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminRuleGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminRuleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminRuleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminRuleGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AdminsRuleGet views instance rules with i ds

The rules will be returned in order (sorted by Order ascending).
*/
func (a *Client) AdminsRuleGet(params *AdminsRuleGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AdminsRuleGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAdminsRuleGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "adminsRuleGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AdminsRuleGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AdminsRuleGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for adminsRuleGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainAllowCreate creates one or more domain allows from a string or a file

	You have two options when using this endpoint: either you can set `import` to `true` and

upload a file containing multiple domain allows, JSON-formatted, or you can leave import as
`false`, and just add one domain allow.

The format of the json file should be something like: `[{"domain":"example.org"},{"domain":"whatever.com","public_comment":"they smell"}]`
*/
func (a *Client) DomainAllowCreate(params *DomainAllowCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainAllowCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainAllowCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_allows",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainAllowCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainAllowCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainAllowCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainAllowDelete deletes domain allow with the given ID
*/
func (a *Client) DomainAllowDelete(params *DomainAllowDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainAllowDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainAllowDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/domain_allows/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainAllowDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainAllowDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainAllowDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainAllowGet views domain allow with the given ID
*/
func (a *Client) DomainAllowGet(params *DomainAllowGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainAllowGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainAllowGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_allows/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainAllowGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainAllowGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainAllowGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainAllowsGet views all domain allows currently in place
*/
func (a *Client) DomainAllowsGet(params *DomainAllowsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainAllowsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainAllowsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainAllowsGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_allows",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainAllowsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainAllowsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainAllowsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainBlockCreate creates one or more domain blocks from a string or a file

	You have two options when using this endpoint: either you can set `import` to `true` and

upload a file containing multiple domain blocks, JSON-formatted, or you can leave import as
`false`, and just add one domain block.

The format of the json file should be something like: `[{"domain":"example.org"},{"domain":"whatever.com","public_comment":"they smell"}]`
*/
func (a *Client) DomainBlockCreate(params *DomainBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainBlockCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainBlockCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainBlockCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainBlockCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainBlockCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainBlockDelete deletes domain block with the given ID
*/
func (a *Client) DomainBlockDelete(params *DomainBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainBlockDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainBlockDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/domain_blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainBlockDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainBlockDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainBlockDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainBlockGet views domain block with the given ID
*/
func (a *Client) DomainBlockGet(params *DomainBlockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlockGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainBlockGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainBlockGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainBlockGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainBlockGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainBlockGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainBlocksGet views all domain blocks currently in place
*/
func (a *Client) DomainBlocksGet(params *DomainBlocksGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainBlocksGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainBlocksGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainBlocksGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainBlocksGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainBlocksGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainBlocksGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainKeysExpire forces expiry of cached public keys for all accounts on the given domain stored in your database

	This is useful in cases where the remote domain has had to rotate their keys for whatever

reason (security issue, data leak, routine safety procedure, etc), and your instance can no
longer communicate with theirs properly using cached keys. A key marked as expired in this way
will be lazily refetched next time a request is made to your instance signed by the owner of that
key, so no further action should be required in order to reestablish communication with that domain.

This endpoint is explicitly not for rotating your *own* keys, it only works for remote instances.

Using this endpoint to expire keys for a domain that hasn't rotated all of their keys is not
harmful and won't break federation, but it is pointless and will cause unnecessary requests to
be performed.
*/
func (a *Client) DomainKeysExpire(params *DomainKeysExpireParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainKeysExpireAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainKeysExpireParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainKeysExpire",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_keys_expire",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainKeysExpireReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainKeysExpireAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainKeysExpire: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionDraftAccept accepts a domain permission draft turning it into an enforced domain permission
*/
func (a *Client) DomainPermissionDraftAccept(params *DomainPermissionDraftAcceptParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftAcceptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionDraftAcceptParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionDraftAccept",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_drafts/{id}/accept",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionDraftAcceptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionDraftAcceptOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionDraftAccept: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionDraftCreate creates a domain permission draft with the given parameters
*/
func (a *Client) DomainPermissionDraftCreate(params *DomainPermissionDraftCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionDraftCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionDraftCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_drafts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionDraftCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionDraftCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionDraftCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionDraftGet gets domain permission draft with the given ID
*/
func (a *Client) DomainPermissionDraftGet(params *DomainPermissionDraftGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionDraftGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionDraftGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_drafts/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionDraftGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionDraftGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionDraftGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionDraftRemove removes a domain permission draft optionally ignoring all future drafts targeting the given domain
*/
func (a *Client) DomainPermissionDraftRemove(params *DomainPermissionDraftRemoveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftRemoveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionDraftRemoveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionDraftRemove",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_drafts/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionDraftRemoveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionDraftRemoveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionDraftRemove: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainPermissionDraftsGet views domain permission drafts

	The drafts will be returned in descending chronological order (newest first), with sequential IDs (bigger = newer).

The next and previous queries can be parsed from the returned Link header.

Example:

```
<https://example.org/api/v1/admin/domain_permission_drafts?limit=20&max_id=01FC0SKA48HNSVR6YKZCQGS2V8>; rel="next", <https://example.org/api/v1/admin/domain_permission_drafts?limit=20&min_id=01FC0SKW5JK2Q4EVAV2B462YY0>; rel="prev"
````
*/
func (a *Client) DomainPermissionDraftsGet(params *DomainPermissionDraftsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionDraftsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionDraftsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionDraftsGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_drafts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionDraftsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionDraftsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionDraftsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainPermissionExcludeCreate creates a domain permission exclude with the given parameters

	Excluded domains (and their subdomains) will not be automatically blocked or allowed when a list of domain permissions is imported or subscribed to.

You can still manually create domain blocks or domain allows for excluded domains, and any new or existing domain blocks or domain allows for an excluded domain will still be enforced.
*/
func (a *Client) DomainPermissionExcludeCreate(params *DomainPermissionExcludeCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionExcludeCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionExcludeCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_excludes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionExcludeCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionExcludeCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionExcludeCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionExcludeDelete removes a domain permission exclude
*/
func (a *Client) DomainPermissionExcludeDelete(params *DomainPermissionExcludeDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionExcludeDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionExcludeDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/domain_permission_excludes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionExcludeDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionExcludeDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionExcludeDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionExcludeGet gets domain permission exclude with the given ID
*/
func (a *Client) DomainPermissionExcludeGet(params *DomainPermissionExcludeGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionExcludeGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionExcludeGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_excludes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionExcludeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionExcludeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionExcludeGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainPermissionExcludesGet views domain permission excludes

	The excludes will be returned in descending chronological order (newest first), with sequential IDs (bigger = newer).

The next and previous queries can be parsed from the returned Link header.

Example:

```
<https://example.org/api/v1/admin/domain_permission_excludes?limit=20&max_id=01FC0SKA48HNSVR6YKZCQGS2V8>; rel="next", <https://example.org/api/v1/admin/domain_permission_excludes?limit=20&min_id=01FC0SKW5JK2Q4EVAV2B462YY0>; rel="prev"
````
*/
func (a *Client) DomainPermissionExcludesGet(params *DomainPermissionExcludesGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionExcludesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionExcludesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionExcludesGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_excludes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionExcludesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionExcludesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionExcludesGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionSubscriptionCreate creates a domain permission subscription with the given parameters
*/
func (a *Client) DomainPermissionSubscriptionCreate(params *DomainPermissionSubscriptionCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionSubscriptionGet gets domain permission subscription with the given ID
*/
func (a *Client) DomainPermissionSubscriptionGet(params *DomainPermissionSubscriptionGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionSubscriptionRemove removes a domain permission subscription
*/
func (a *Client) DomainPermissionSubscriptionRemove(params *DomainPermissionSubscriptionRemoveParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionRemoveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionRemoveParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionRemove",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions/{id}/remove",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionRemoveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionRemoveOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionRemove: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainPermissionSubscriptionTest tests one domain permission subscription by making your instance fetch and parse it without creating permissions

	The response body will be a list of domain permissions that *would* be created by this subscription, OR an error message.

This is useful in cases where you want to check that your instance can actually fetch + parse a list.
*/
func (a *Client) DomainPermissionSubscriptionTest(params *DomainPermissionSubscriptionTestParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionTestOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionTestParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionTest",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions/{id}/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionTestReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionTestOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionTest: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionSubscriptionUpdate updates a domain permission subscription with the given parameters
*/
func (a *Client) DomainPermissionSubscriptionUpdate(params *DomainPermissionSubscriptionUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionUpdate",
		Method:             "PATCH",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions/${id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data", "application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	DomainPermissionSubscriptionsGet views domain permission subscriptions

	The subscriptions will be returned in descending chronological order (newest first), with sequential IDs (bigger = newer).

The next and previous queries can be parsed from the returned Link header.

Example:

```
<https://example.org/api/v1/admin/domain_permission_subscriptions?limit=20&max_id=01FC0SKA48HNSVR6YKZCQGS2V8>; rel="next", <https://example.org/api/v1/admin/domain_permission_subscriptions?limit=20&min_id=01FC0SKW5JK2Q4EVAV2B462YY0>; rel="prev"
````
*/
func (a *Client) DomainPermissionSubscriptionsGet(params *DomainPermissionSubscriptionsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionsGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DomainPermissionSubscriptionsPreviewGet views all domain permission subscriptions of the given permission type in priority order highest to lowest

This view allows you to see the order in which domain permissions will actually be fetched and created.
*/
func (a *Client) DomainPermissionSubscriptionsPreviewGet(params *DomainPermissionSubscriptionsPreviewGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DomainPermissionSubscriptionsPreviewGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDomainPermissionSubscriptionsPreviewGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "domainPermissionSubscriptionsPreviewGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/domain_permission_subscriptions/preview",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DomainPermissionSubscriptionsPreviewGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DomainPermissionSubscriptionsPreviewGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for domainPermissionSubscriptionsPreviewGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
EmojiCategoriesGet gets a list of existing emoji categories
*/
func (a *Client) EmojiCategoriesGet(params *EmojiCategoriesGetParams, opts ...ClientOption) (*EmojiCategoriesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojiCategoriesGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojiCategoriesGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/custom_emojis/categories",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojiCategoriesGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojiCategoriesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojiCategoriesGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
EmojiCreate uploads and create a new instance emoji
*/
func (a *Client) EmojiCreate(params *EmojiCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojiCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojiCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/custom_emojis",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojiCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojiCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojiCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	EmojiDelete deletes a local emoji with the given ID from the instance

	Emoji with the given ID will no longer be available to use on the instance.

If you just want to update the emoji image instead, use the `/api/v1/admin/custom_emojis/{id}` PATCH route.

To disable emojis from **remote** instances, use the `/api/v1/admin/custom_emojis/{id}` PATCH route.
*/
func (a *Client) EmojiDelete(params *EmojiDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojiDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojiDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/custom_emojis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojiDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojiDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojiDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
EmojiGet gets the admin view of a single emoji
*/
func (a *Client) EmojiGet(params *EmojiGetParams, opts ...ClientOption) (*EmojiGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojiGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojiGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/custom_emojis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojiGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojiGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojiGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	EmojiUpdate performs admin action on a local or remote emoji known to this instance

	Action performed depends upon the action `type` provided.

`disable`: disable a REMOTE emoji from being used/displayed on this instance. Does not work for local emojis.

`copy`: copy a REMOTE emoji to this instance. When doing this action, a shortcode MUST be provided, and it must
be unique among emojis already present on this instance. A category MAY be provided, and the copied emoji will then
be put into the provided category.

`modify`: modify a LOCAL emoji. You can provide a new image for the emoji and/or update the category.

Local emojis cannot be deleted using this endpoint. To delete a local emoji, check DELETE /api/v1/admin/custom_emojis/{id} instead.
*/
func (a *Client) EmojiUpdate(params *EmojiUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*EmojiUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojiUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojiUpdate",
		Method:             "PATCH",
		PathPattern:        "/api/v1/admin/custom_emojis/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojiUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojiUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojiUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	EmojisGet views local and remote emojis available to known by this instance

	The next and previous queries can be parsed from the returned Link header.

Example:

`<http://localhost:8080/api/v1/admin/custom_emojis?limit=30&max_shortcode_domain=yell@fossbros-anonymous.io&filter=domain:all>; rel="next", <http://localhost:8080/api/v1/admin/custom_emojis?limit=30&min_shortcode_domain=rainbow@&filter=domain:all>; rel="prev"`
*/
func (a *Client) EmojisGet(params *EmojisGetParams, opts ...ClientOption) (*EmojisGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEmojisGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "emojisGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/custom_emojis",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EmojisGetReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EmojisGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for emojisGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	HeaderFilterAllowCreate creates new allow HTTP request header filter

	The parameters can also be given in the body of the request, as JSON, if the content-type is set to 'application/json'.

The parameters can also be given in the body of the request, as XML, if the content-type is set to 'application/xml'.
*/
func (a *Client) HeaderFilterAllowCreate(params *HeaderFilterAllowCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterAllowCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterAllowCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/header_allows",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterAllowCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterAllowCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterAllowCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterAllowDelete deletes the allow header filter with the given ID
*/
func (a *Client) HeaderFilterAllowDelete(params *HeaderFilterAllowDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterAllowDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterAllowDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/header_allows/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterAllowDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterAllowDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterAllowDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterAllowGet gets allow header filter with the given ID
*/
func (a *Client) HeaderFilterAllowGet(params *HeaderFilterAllowGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterAllowGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterAllowGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/header_allows/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterAllowGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterAllowGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterAllowGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterAllowsGet gets all allow header filters currently in place
*/
func (a *Client) HeaderFilterAllowsGet(params *HeaderFilterAllowsGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterAllowsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterAllowsGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterAllowsGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/header_allows",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterAllowsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterAllowsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterAllowsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	HeaderFilterBlockCreate creates new block HTTP request header filter

	The parameters can also be given in the body of the request, as JSON, if the content-type is set to 'application/json'.

The parameters can also be given in the body of the request, as XML, if the content-type is set to 'application/xml'.
*/
func (a *Client) HeaderFilterBlockCreate(params *HeaderFilterBlockCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterBlockCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterBlockCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/header_blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterBlockCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterBlockCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterBlockCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterBlockDelete deletes the block header filter with the given ID
*/
func (a *Client) HeaderFilterBlockDelete(params *HeaderFilterBlockDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterBlockDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterBlockDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/header_blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterBlockDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterBlockDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterBlockDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterBlockGet gets block header filter with the given ID
*/
func (a *Client) HeaderFilterBlockGet(params *HeaderFilterBlockGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlockGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterBlockGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterBlockGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/header_blocks/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterBlockGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterBlockGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterBlockGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
HeaderFilterBlocksGet gets all allow header filters currently in place
*/
func (a *Client) HeaderFilterBlocksGet(params *HeaderFilterBlocksGetParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*HeaderFilterBlocksGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewHeaderFilterBlocksGetParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "headerFilterBlocksGet",
		Method:             "GET",
		PathPattern:        "/api/v1/admin/header_blocks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &HeaderFilterBlocksGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*HeaderFilterBlocksGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for headerFilterBlocksGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
MediaCleanup cleans up remote media older than the specified number of days

Also cleans up unused headers + avatars from the media cache and prunes orphaned items from storage.
*/
func (a *Client) MediaCleanup(params *MediaCleanupParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MediaCleanupOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMediaCleanupParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "mediaCleanup",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/media_cleanup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json", "application/xml", "application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &MediaCleanupReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MediaCleanupOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for mediaCleanup: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	MediaRefetch refetches media specified in the database but missing from storage

	Currently, this only includes remote emojis.

This endpoint is useful when data loss has occurred, and you want to try to recover to a working state.
*/
func (a *Client) MediaRefetch(params *MediaRefetchParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MediaRefetchAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMediaRefetchParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "mediaRefetch",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/media_refetch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &MediaRefetchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MediaRefetchAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for mediaRefetch: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RuleCreate creates a new instance rule
*/
func (a *Client) RuleCreate(params *RuleCreateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRuleCreateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ruleCreate",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/instance/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RuleCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RuleCreateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ruleCreate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RuleDelete deletes an existing instance rule
*/
func (a *Client) RuleDelete(params *RuleDeleteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRuleDeleteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ruleDelete",
		Method:             "DELETE",
		PathPattern:        "/api/v1/admin/instance/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RuleDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RuleDeleteOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ruleDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RuleUpdate updates an existing instance rule
*/
func (a *Client) RuleUpdate(params *RuleUpdateParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RuleUpdateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRuleUpdateParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "ruleUpdate",
		Method:             "PATCH",
		PathPattern:        "/api/v1/admin/instance/rules/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RuleUpdateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RuleUpdateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ruleUpdate: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
	TestEmailSend sends a generic test email to a specified email address

	This can be used to validate an instance's SMTP configuration, and to debug any potential issues.

If an error is returned by the SMTP connection, this handler will return code 422 to indicate that
the request could not be processed, and the SMTP error will be returned to the caller.
*/
func (a *Client) TestEmailSend(params *TestEmailSendParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TestEmailSendAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestEmailSendParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "testEmailSend",
		Method:             "POST",
		PathPattern:        "/api/v1/admin/email/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TestEmailSendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*TestEmailSendAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for testEmailSend: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
